
### 存储器的多层结构
  最高层：CPU寄存器
  中   间：主存
  底   层：辅存
  
  计算机系统存储层次

可执行存储器：主存储器、寄存器
  在访问辅存时等耗费的时间相差3个数量级


### 主储存器：
主存储器访问速度远低于CPU执行指令的速度，为缓和这一矛盾，在计算机系统中引入了寄存器和高速缓存
寄存器：快，贵，小

### 高速缓存：
它是介于寄存器和存储器之间的存储器，主要用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数，访问速度快于主存储器
磁盘缓存：用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数，利用主存中的部分存储空间暂时存放从磁盘中读出(或写入)的信息。主存也可以看作是辅存的高速缓存
  文件的数据存储	在辅存（硬盘）
  运行或访问时	调入主存或暂时存放在主存的磁盘高速缓存


## 
用户程序->装入内存->编译->链接->装入->可执行程序



### 静态链接方式
：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开

在将这几个目标模块装配成一个装入模块时，须解决以下两个问题： 
(1) 对相对地址进行修改。B加上L，C加上L+M
(2) 变换外部调用符号。 B变为L，C变为L+M

装入时动态链接：在装入内存时，采用边装入边链接的链接方式。在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存，还要按照图4-4所示的方式修改目标模块中的相对地址

运行时动态链接：将对某些模块的链接推迟到程序执行时才进行。也就是在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS 去找到该模块，并将之装入内存，将其链接到调用者模块上。


### 绝对装入方式
：用户程序经编译后，将产生绝对地址(即物理地址)的目标代码。
  只能将目标模块装入到内存中事先指定的位置，这只适用于单道程序环境。 

可重定位装入方式：根据内存的具体情况将装入模块装入到内存的适当位置。（多道程序环境）


在采用可重定位装入程序将装入模块装入内存后，会使装入模块中的所有逻辑地址与实际装入内存后的物理地址不同。
把在装入时对目标程序中指令和数据地址的修改过程称为重定位。又因为地址变换通常是在进程装入时一次完成的，以后不再改变，故称为静态重定位。
  不允许程序运行时在内存中移动位置

动态运行时的装入方式：在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行。



## 连续分配存储管理方式


### 单一连续分配\
：把内存分为系统区和用户区两部分。
  系统区提供给OS使用，通常是放在内存的低址部分。
  用户区内存中，仅装有一道用户程序，独占整个内存。



### 固定分区分配
：将整个用户空间划分为若干个固定大小的区域，在每个分区中只装入一道作业。
  1、划分分区的方法：（按照下述两种方法）
  分区大小相等
  分区大小不等
  2、内存分配
  将分区按其大小进行排队，并为之建立一张分区使用表，其中各表项包括每个分区的起始地址、大小及状态(是否已分配)
  



### 动态分区分配（可变分区分配）
：根据进程的实际需要，动态地为之分配内存空间。
  ○ 数据结构（顺序表和链式结构）
  空闲分区表
  
  空闲分区链
  
  ○ 动态分区分配算法
  新作业装入内存时按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业。
  ○ 分区的分配与回收操作
  1)  分配内存
  
  内存分配流程
  空闲分区链(表)中找到所需大小的分区。设请求的分区大小为u.size，表中每个空闲分区的大小可表示为m.size。
  size是事先规定的不能分割的分区大小
  2)  回收内存
  1、回收区与前一个空闲分区F1相接
  2、回收区与后一个空闲分区F2相接
  3、回收区在两个空闲分区F1、F2之间
  4、回收区不与任何空闲分区相接  
  这时应为回收区单独建立一个新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。
  


### 首次适应算法
：从链首开始顺序查找，直至找到满足要求的空闲分区。按照作业的大小，划分内存空间，分配给请求者。若不能找到一个能满足要求的分区，则内存分配失败，返回。
  其缺点是低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，称为碎片。（无法利用，占空间）
  从头开始无效的查找
循环首次适应算法：从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。使内存中的空闲分区分布得更均匀，但缺乏大的空闲分区。
最佳适应算法：为作业分配内存时，把能满足要求、最小的空闲分区分配给作业。该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。
  额外需要时间，排序
  形成更多碎片
  但不会牺牲大的分区
最坏适应算法：在扫描整个空闲分区表或链表时，挑选最大的空闲区，从中分割一部分存储空间给作业使用。故存储器中缺乏大空闲分区。
  不容易产生碎片



### 动态可重定位分区分配
  紧凑：把碎片“紧凑”起来，拼接成大分区
  动态重定位：
  
  4.2.1作业装入内存地址是相对(逻辑)地址。
  为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，在系统中增设一个重定位寄存器，用它来存放程序(数据)在内存中的起始地址
  真正访问的内存地址 = 相对地址 + 重定位寄存器中的地址 
  
  动态重定位分区分配算法：在这种分配算法中，与动态重定位相比增加了紧凑的功能。 ->在没有足够的分区时开始紧凑，如果找不到返回失败
  
  



## 
对换：系统把所有的作业存入磁盘，每次调一个作业进入内存，当该作业的一个时间片用完时，将它调至外存的后备队列，从后备队列上将另一个作业调入内存。
  有一台 I/O速度较高的外存，而且容量也必须足够大。


### 多道程序环境下的对换技术
  对换的引入
  内存中部分进程被阻塞，占用大量的内存，甚至内存中所有进程都被阻塞，而无可运行的进程，使CPU一直等待
  部分作业因内存空间不足一直在外存上不能进入内存运行
  系统资源浪费，系统吞吐量下降。 
  对换的类型
  整体对换
  对换是以整个进程为单位的。
  页面（分段）对换
  


### 对换空间的管理
  1. 对换空间管理的主要目标
  ○ 对文件区管理的主要目标
  离散分配方式
  ○ 对对换空间管理的主要目标
  连续分配方式
  2. 对换区空闲盘块管理中的数据结构
  空闲分区表或空闲分区链
  空闲分区表：对换区的首址 + 大小（盘块号 + 盘块数）
  3. 对换空间的分配与回收
  1、回收区与前一个空闲分区F1相接
  2、回收区与后一个空闲分区F2相接
  3、回收区在两个空闲分区F1、F2之间
  4、回收区不与任何空闲分区相接  
  
  


### 进程的换出和换入
  1. 进程的换出
  选择被换出的进程
  进程的状态、进程的优先级。
  如果系统中已无阻塞进程，而现在的内存空间仍不足以满足需要，便选择优先级最低的就绪进程换出。
  进程换出过程
  对于共享的程序和数据段，只要还有进程需要就不能被换出。 
  2. 进程的换入
  查看PCB集合中所有进程的状态，从中找出“就绪”状态但已换出的进程。进程较多时，选择已换出到磁盘上时间最久(大于规定时间)的进程作为换入进程。
  如果失败，则将内存中的某些进程换出，腾出足够的内存空间后，将进程调入。


## 分页存储管理方式
：将一个进程直接分散地装入到许多不相邻接的分区中。
(1) 分页存储管理方式。
(2) 分段存储管理方式。
(3) 段页式存储管理方式。 

### 分页存储管理的基本方法
  1. 页面和物理块
  页面：进程的逻辑地址空间分成若干个页，并为各页加以编号，从0开始，如第0页、第1页等。
  内存的物理地址空间分成若干个块，同样也为它们加以编号，如0#块、1#块等等。
  因为一页装不满形成不可利用的“页内碎片”。
  页面大小：
  页面小的优点：碎片少，内存利用率高
  缺点：页面多，页表长，占用内存，降低页面
   换进换出效率
  页面大小应是2的幂，通常为1KB～8KB。
  2. 地址结构:页号+页内地址
  
  给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得：
  
  例:系统的页面大小1KB，设A=2170B，则由上式可以求得P=2，d=122
   INT取整 MOD取余
  3. 页表：分页系统中允许进程的各个页离散地存储在内存的任一物理块中。在内存中找到每个页面所对应的物理块。系统为每个进程建立了一张页面映像表，简称页表。
  


### 地址变换机构
  1. 基本的地址变换机构
  一个页表项用一个寄存器。（页表寄存器PTR在其中存放页表在内存的始址和页表的长度） 在单处理机环境下，虽然系统中可以运行多个进程，但只需一个页表寄存器。
  
  页面大小为1024B
  试将逻辑地址1011，2148，3000，4000，5012转化为相应的物理地址。
  页号	块号
  0	2
  1	3
  2	1
  3	6
  答案：
  1011	3059
  2148	1124
  3000	1976
  4000	7072
  5012	越界
  2. 具有快表的地址变换机构
页表存放在内存中，在CPU存取数据时，都要两次访问内存。第一次：访问内存中的页表，找到指定页的物理块号->将块号与页内偏移量W拼接，以形成物理地址。第二次：从第一次所得地址中获得所需数据(或向此地址中写入数据)。
  （寄存器和内存的速度差）
具有并行查寻能力的特殊高速缓冲寄存器，又称为"联想寄存器"或"快表"
  
   CPU给有效地址，地址变换机构自动将页号P送入高速缓冲寄存器，将此页号与高速缓存中的所有页号进行比较，从快表中读出对应的物理块号，送进物理地址寄存器。
   在快表中未找到对应的页表项，访问内存中的页表，找到后，把读出的物理块号送往地址寄存器，再将此页表项存入快表的一个寄存器单元中。如果联想寄存器已满，则OS找到一个老的且不再需要的页表项将它换出


### 两级和多级页表：解决页表大，占用很大内存空间的问题：
  ①采用离散分配方式，解决找不到连续的大内存空间的问题
  ②需要的页表项调入内存，其余的页表项驻留磁盘，需要时调入
1、两级页表
  将页表分页，使页面与内存物理块的大小相同，并且编号，即依次为0#页、1#页，…，n#页，然后离散地将各个页面存放进不同的物理块。
  为离散分配的页表建立一张页表，每个页表项中记录了页表页面的物理块号。 
  
  
   在采用两级页表结构时，对页表进行分页，每页有2¹⁰（1024）个页表项，最多有2¹⁰个页表分页。
  
  
  为方便地址变换，增设一个外层页表寄存器，用于存放外层页表的始址，用逻辑地址中外层页号作为外层页表的索引，从中找到指定页表分页的始址，再利用P2作为指定页表分页的索引，找到指定的页表项，其中即含有该页在内存的物理块号，用该块号P和页内地址d即可构成访问的内存物理地址。
2、多级页表
  对于64位的机器，采用两级页表不合适。应该采用多级页表，将外层页表再进行分页。


### 
分段式存储管理方式：为了满足用户（程序员）在编程和使用上多方面的要求，其中有些要求是其它几种存储管理方式所难以满足的。


### 分段存储管理方式的引入
：一：通常的程序都可分为若干个段，如主程序段、子程序段 A、子程序段B、…、数据段以及栈段等，每个段大多是一个相对独立的逻辑单位;
  二：实现和满足信息共享、信息保护、动态链接以及信息的动态增长等需要，是以（逻辑的）段为基本单位的。
  1.方便编程：需要访问的逻辑地址是由段名(段号)和段内偏移量(段内地址)决定的，方便程序员编程，程序直观，可读性。
  2.信息共享：为被共享的过程建立一个段，简化共享的实现
  3.信息保护：不能动，只有“我”可以动
  4.动态增长
  5.动态链接：系统只将真正要运行的目标程序装入内存，动态链接在作业运行之前，并不是把所有的目标程序段都链接起来。


### 分段系统的基本原理
  1.分段
  主程序段MAIN、子程序段X、数据段D及栈段S
  
  
  
  
  2.段表:为每个分段分配一个连续的分区。进程中的各个段，可以离散地装入内存中不同的分区中。为保证程序能正常运行，就必须能从物理内存中找出每个逻辑段所对应的位置。 
  
  3.地址变换机构
  
  
  
  4.分页和分段的主要区别
  (1) 页是信息的物理单位。
  实现离散分配方式，以消减内存的外零头，提高内存的利用率。
  分页仅仅只是系统管理上的需要，完全是系统的行为，对用户是不可见的。
  分段存储管理方式中的段则是信息的逻辑单位，它通常包含的是一组意义相对完整的信息。
  (2) 页的大小固定且由系统决定。
  (3) 分页的用户程序地址空间是一维的。 



### 

