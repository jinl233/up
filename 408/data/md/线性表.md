---
tags: [Data Structure]
title: 线性表
created: '2024-06-06T07:41:33.840Z'
modified: '2024-06-06T08:21:10.093Z'
---

# 线性表定义
### 特性
数据元素类型、有限、有序
### 重要术语

- 表长、空表
- 表头、表尾
- 前驱、后继
- 数据元素位序
# 基本操作

### 创销、增删改查

### 判空、判长、打印输出

### 传参引用&

### 命名可读性
<!-- $\alpha$
$\frac{abc}{xyz}$ -->

# 顺序表示c

- 线性表
相同数据结构元素集合
- 顺序表
顺序存储线性表

# 代码
定义
```c
#include "stdio.h"
#include "windows.h"
#include "stdlib.h"

#define MAXSIZE 20//顺序表最大长度
#LIST INIT SIZE 10
/*定义顺序表*/
typedef struct {
	int data[MAXSIZE];
	int length;
}SeqList;
```
初始化
```c
status InitList sq(sqList &L)//构造一个空的顺序表L
{
    L.elem=(ElemType*) mallOC(LIST INIT SIZE*sizeof(ElemType));
    if(!L.elem)
        exit(OVERFLOW);//存储空间分配失败
    L.length=0;
    L.listsize=LIST INIT SIZE;
    return Ok;
}
```
销毁
```c
void DestroyList_sq(sqList &L)
{
    free(L.elem);
    L.elem=NULL;
    L.length=0;
    L.listsize=0;
}
```
判空
```c
void ListEmpty_sq(L)
{
    return (L.length==0);
}
```
输出
```c
status DispList sq(sqList L)
{
    if( ListEmpty_Sq(L))
        return ERROR;
    for(i=0; i<L.length; i++)
        printf( L.elem[i]);
    return Ok;

}
```
插入
```c
status ListInsert sq( sqList &L, int i, ElemType e)
{
    if(i<1 i>L.length+1)
        return ERROR;
    if(L.Length>=L.listsize)
    {
        newbase=(ElemType*)realloc(L.elem,(L.listsize + LISTINCREMENT)*sizeof(ElemType));
        if(!newbase)
            exit( OVERFLOW );//存储分配失败
        L.elem=newbase;
        L.listsize+=LISTINCREMENT;
    } 
    for(j=L.length; j>=i; j--)
        L.elem[j]= L.elem[j-1];
    L.elem[i-1]=e;
    ++L.length;
    return OK;
}
```
删除
```c
status ListDelete_sq(sqList &L, int i, ElemType &e)
{
    if(i<1||i>L,length)
        return ERROR;
    e=L.elem[i-1];
    for( j=i; j<L.length; j++ )
        L.elem[j-1]= L.elem[j];
    --L.length;
    return OK;
}
```
按位查找，获取表中第i个元素的值
```c
ElemType GetElem(seqList L,int i)
{
    return L.data[i-1];
}
```
获取值为e的值
```c
int LocateElem(seqList L,ElemType e)
{
    for(int i=0;i<L.length;i++)
        if(L.data[i]==e)
            return i+1;
    return 0;
}
```
