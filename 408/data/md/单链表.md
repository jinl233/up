---
tags:
  - Data
  - Structure
title: 单链表
created: 2024-06-06T07:41:33.780Z
modified: 2024-06-06T08:21:14.405Z
---

# 单链表代码

### 定义

```c
typedef struct LNode
{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;

LNode *L;
LinkList L; 
// 声明指向单链表第一个节点的指针
```

###### 头节点

- 无头结点单链表
  空表时，head为NULL

- 有头结点单链表
  空表时，head指向头结点
  便于插入/删除的实现

### 初始化无头结点单链表

```c
bool InitList(LinkList &L)
{
    L = NULL;
    return true;
}
```

判断链表是否为空

```c
bool Empty(LinkList L)
{
    if(L = NULL);
        return true;
    else
        return false;
}
```

### 初始化有头结点单链表

```c
bool InitList(LinkList &L)
{
    L = (LNode *)malloc(sizeof(LNode));
    if(L = NULL);
        return true;
    L->next = NULL;
    return true;
}
```

判断链表是否为空

```c
bool Empty(LinkList L)
{
    if(L = NULL);
        return true;
    else
        return false;
}
```

### 带头节点按位插入

```c
status ListInsert(LinkList &L,int i, ElemType e)
{
    p=L; 
    j=0;
    while( j<i-1 && p!=NULL )
    {
        j++;
        p=p->next;
    }end of while
    if(p==NULL| j>i-1)
        return ERROR;
    s=(LinkList)malloc(sizeof(LNode));
    if(S ==NULL)
        exit( OVERFLOW );
    s->data=e;
    s->next=p->next;
    p->next=s;
    return OK;
}
```

### 不带头节点按位插入

```c
int ListInsert(LinkList &L,int i,ElemType e)
{
    if(i==1)
    {
        s=(LinkList)malloc(sizeof(LNode));
        if(S==NULL)
            exit(OVERFLOW);
        s->data=e;
        s->next=L;
        L=s;
    }
    else 
    {
        p=L; 
        j=1;
        ......
    }
    return Ok;
}
```

### 删除第i个元素，带头节点

```c
int ListDelete(LinkList &L,int i, ElemType &e)
{
    j=0;
    p=L;
    while(j<i-1 && p->next)
    {
        j++;
        p=p->next;
    }
    if(!(p->next)|j>i-1)
        return ERROR;
    q=p->next;
    e=q->data;
    p->next=q->next;
    free(q);
    return oK;
}
```

### 查找第i个元素

```c
int GetElem(LinkList L,int i, ElemType &e)
{
    p=L->next;
    j=1;
    while( j<i && p!=NULL )
    {
        j++;
        p=p->next;
    }
    if( j>i P==NULL )
        return 0;
    e=p->data;
    return 1;
}
```

### 查找值为e的元素，有则返回位置

```c
int LocateElem(LinkList L,ElemType e )
{
    p=L->next;
    n=1;
    while( p!=NULL && p->data!=e )
    {
        p=p->next;
        n++;
    }
    if(p==NULL)
        return 0;
    else return n;
}
```

### :star::star::star:尾插法

```c
void createList LR(LinkList &L,int n)
{
    L=(LinkList)malloc(sizeof(LNode));L->next=NULL;
    r=L;
    for( i=0; i<n; i++ )
    {
        s=(LinkList)malloc(sizeof(LNode))scanf(&s->data );
        r->next=s;
        r=S;
        r->next=NULL;
    }
}
```

### :star::star::star:头插法

```c
void createList LF(LinkList&L,int n)
{
    L=(LinkList)malloc(sizeof(LNode));
    L->next = NULL;
    for(i=0;i<n;i++)
    {
        s=(LinkList)malloc(sizeof(LNode));
        scanf(&s->data);
        s->next =L->next;
        L->next = s;
    }
}
```
