# 移位运算

## 逻辑移位
- 对象
  无符号数  
- 规则
  - 逻辑左移
  高位移除，低位补0  
  ![图 0](../../images/3fed804b48a764fd810c89641842de9778cf4e49601462aa19821483ea27412c.png)    


  - 逻辑右移  
  低位移除，高位补0 
  ![图 1](../../images/f2bc03175be0b33c3075585ac9844dc2f34013a0d50dfe458add9f35afef7b5a.png)  
 
## 算术移位
- 对象
  有`符号数`(针对定点数，包括定点整数和定点小数)
- 不论正数还是负数，**符号位保特不变**，`仅对数值位进行移位`（左移或右移）
- 对真值的原码、反码和补码进行`算术移位`后，它们`各自所对应的新的真值应该保持一致`
#### 真值为`正数`
`真值的原码、反码和补码`都`相同`，因此，对它们进行`算术移位`后，它们各自所对应的新的真值自然是保持一致的。对于移位后出现的`空位`，规定**添补0**
- 左移时，若最高位丢1，则结果出错
- 右移时，若最低位丢1，则精度缺失
    ![图 2](../../images/d78db3f1524b4ecdceb202c7cf41d65192d000a60ee29ec13a481af12f310b4d.png)  
    ![图 3](../../images/b0f9da1430f8d8adca984e54df27aa24a20edafc430553e890aaad82a1a0f8fc.png) 

#### 真值为`负数`
`真值的原码、反码和补码`都`不同`，因此，对它们进行`算术移位后`，为了确保`它们各自所对应的新的真值保持一致`，对于移位后出现的`空位`，规定不同
![图 5](../../images/92600e26de627f497492efb82ca08514cf541726fbbe58ba155b4cad2d8f6a6f.png)  

### 总结
![图 6](../../images/b8b53aa4b4218b5153dda5ae40d022080853d5ab35faf2feb634512b3f28d2de.png)  

### 符号位也参与移位
- 左移  
  - 高位移除，低位添补0  
  - 移动前后若符号位发生变化，则发生溢出  
- 右移  
  - 低位移除，高位添补符号  
    ![图 7](../../images/c319943713220e7bf08741a1278fb49d1e2a5e1edd4dfd510cc3f169b05c93f8.png)  

- 优点
    - 左移时，有检测出发生溢出的方法：符号位发生变化可判定溢出
    - 符号位与数值位一起移位，方便LU处理，也方便记忆



### C语言中的移位运算

- `左移`运算操作符“<”对应汇编指令中的逻辑左移，即**高位移除**，**低位补0**
- `右移`运算操作符“>>”则根据操作数是无符号还是有符号类型分别对应汇编指令中的逻辑右移和算术右移指令
  - `逻辑右移`：将**低位移除**，**高位补0**
  - `算术右移`：将**低位移除**，**高位补原数据的符号位**
![图 8](../../images/e2defa596fa3dbb6ee7354f857449b48d04e9847ccab5b6733862d494650e51c.png)  




## 循环移位

- 对象
  无符号数  
- 将无符号数二进制形式中的各个位向左或向右移动，被移出的位会重新出现在另一端，形成循环  
  
在很多处理器架构中，循环移位指令会影响状态寄存器中的进位标志CF(Carry Flag)位，CF标志位用于标识在执行算术或逻辑操作时是否发生了进位
```mermaid
graph LR
    小循环-->不带CF标志位的循环右移;
    小循环-->不带CF标志位的循环左移;
    大循环-->带CF标志位的循环右移;
    大循环-->带CF标志位的循环左移;
```
#### 不带CF标志位的循环右移
![图 9](../../images/f89c85b4a8cdb0c4b8971cc73b8bd6a5526cc7b58a238cca6133d1143fb9ded9.png)  


#### 不带CF标志位的循环左移
![图 10](../../images/b74aab1adfc0cbd0f2184babb73a64e1013711a18b4445f91fa5bc5ff22b6034.png)  


#### 带CF标志位的循环右移
![图 11](../../images/a533505bcc2e4db5a3b626c30564d0e0e6afe0340decd952650495765ee1d16e.png)  


#### 带CF标志位的循环左移
![图 12](../../images/c33595ec1276c3e47cb9b40ef1280b3dee25dbf8f6c5812848327a5b156e6a29.png)  


#### 应用
- `加密算法`
  - 通过循环移位可以实现数据的混淆和置换，增强加密算法的安全性。
- `哈希函数`
  - 通过循环移位可以用来改变输入数据的排列顺序，以产生不同的哈希值，有利于增强哈希函数的混淆性和扩散性。
- `优化算法`
  - 在某些算法中，循环移位可以用于优化性能和节省资源。例如，在图形处理和数字信号处理中，循环移位可以用于加速算法的执行。

#### C语言实现
- C语言中并没有直接提供循环移位操作符。
  - 通常情况下，可以使用`移位运算操作符`(例如：左移“<<”或右移“>>”)和`位运算操作符`(或运算“|”)来实现。
```c
#include <stdio.h>
/*循环左移*/
unsigned int circularLeftShift(unsigned int value, int n)
{
    return (value << n) | (value >> (32 - n));
}

/*循环右移*/
unsigned int circularRightShift(unsigned int value, int n)
{
    return (value >> n) | (value << (32 - n));
}
int main()
{
    unsigned int usi = 0x12345678; // 待循环移位的32位无符号整数
    int d = 4;                     // 移位距离（即一次循环移动几位）

    printf("Original value:0x%x\n", usi);
    printf("Circular left shift by %d bits:0x%x\n", d, circularLeftShift(usi, d));
    printf("Circular right shift by %d bits:0x%x\n", d, circularRightShift(usi, d));

    return 0;
}
```

--- 
# 定点数的加法和减法运算
## 补码加减法运算公式
定点数（定点整数和定点小数）在计算机内部采用补码表示 **(运算规则简单，易于实现)**
- 补码的符号位可以与数值位一起参加运算
- 采用补码可将减法运算转换成加法运算
#### 公式
$[ A ] _ { 补 } + [ B ] _ { 补 } = [ A + B ] _ { 补 }$   
$[ A ] _ { 补 } - [ B ] _ { 补 } = [ A - B ] _ { 补 } = [ A ] _ { 补 } + [ - B ] _ { 补 }$
$$
(\mod M)
\begin{cases}
定点整数:M=2^{n+1} \\ \qquad ._{n为补码数值位的位数}\\
\\
定点小数:M=2^1=2\\
\end{cases}
$$
> [! example] $\quad$[补码定义](/408/principles/dataRepre.md#补码)$\qquad$[运算公式证明过程](https://www.bilibili.com/video/BV1yr42187B1?t=180.7&p=25)
 

## 补码加减法运算的溢出检测
#### 判断溢出的方法1
根据`操作数的符号位`与`运算结果的符号位`是否一致进行判断
- 两个操作数**相加**时，当它们的**符号位相同**（即同正或同负）时，才**可能发生溢出**


```mermaid
graph LR
    溢出-->运算结果的符号位与原操作数的符号位不同;
    未溢出-->运算结果的符号位与原操作数的符号位相同;
```
![图 16](../../images/ea922061fd71ace270b2b3bdc22be4598e75f26a7261e39f59593aaf9448a056.png)  


#### 判断溢出的方法2
根据运算过程中`最高数值位的进位`与`符号位的进位`是否一致进行判断
- **不同**可判定为**溢出**
- **相同**可判定为**没有溢出**
<!-- ![图 17](../../images/e90db2b938ff1eb9c49cf9e58e6bd618475170ad5faf018f3cfbb4615e2ed62d.png)   -->
![图 18](../../images/e17c04d6d8918ed68131f9f7fdade0be82731b2173c07b8d52baa5c86ef6f572.png)  

- 最高数值位的进位记为$C_{n-1}$
- 符号位的进位记为$C_{n}$
- 溢出标志位记为0F,当0F为1时表示发生溢出  
$C_{n-1}$与$C_{n}$不同，则产生溢出(即0F为1)  
$OF = C _ { n - 1 } \oplus C _ { n }$

#### 判断溢出的方法3
利用`变形补码`(具有2位符号位的补码)的符号位进行判断  
- 变形补码也称为`双符号补码`，具有2个符号位，其余与补码相同
  - 双符号位为**00**时，表示**正数**
  - 双符号位为**11**时，表示**负数**
  - 双符号位为**01**时，表示**正溢出**
  - 双符号位为**10**时，表示**负溢出**  

> [! success] 正溢出和负溢出判断非常直观，适合手工运算时的溢出检测，但其硬件成本高，在计算机中主要采用单符号溢出检测方案

> [! info] 负数变形补码转换成原码仍可以使用反码法或扫描法


## 逻辑代数和逻辑门
#### 与门
![图 19](../../images/f1d28124089d59ca434b5bf62084d3d3589bbb3d0bc65a77ada8348ffa48b672.png)  

#### 或门
![图 20](../../images/39b223f3ea3d1029bb713fd8ee8a3e0897f90ebb2f65e8717d117470098dae15.png)  

#### 非门
![图 21](../../images/fdb71a7d3bb19ae28c7f46f74ca5d08e74e40c305c0371234a21326a52f56f48.png)  

#### 与非门
![图 22](../../images/d4a0a9375859c621cc4de6965ab43d5c1afe17038a39bd3afd14e0083adfb12f.png)  
![图 24](../../images/2c9fd101d0bc3dab04696e3d514bc6b9fe42295fddb0ddc7b3334da9d43a07dc.png)  

#### 或非门
![图 25](../../images/d996a30762c0667d894da8818af89c2d57b875e41d31ec53c7cf648b6669e6ef.png)  

#### 异或门
![图 26](../../images/cd31f8ff348f1f75e8b7ad1d73e27d92e09f52a22aa615bdf8e3f68385deeb1c.png)  

#### 同或门
![图 27](../../images/d25156f4e5f2f51718d6b229aa9d92f9c816a893e0075a78e1a55459e48b12be.png)  


## 串行进位加法器的硬件逻辑实现

<!-- 
!!! success  一位全加器的硬件逻辑实现

    ![图 28](../../images/04e484ab764132a4bf153feb9fc1e45e1e385b4a98cc8ad2d7485c47f80e1ca9.png)  
    ### 逻辑门
    ![图 29](../../images/fad53e0acd38225b0dfdd0275ac98ffaf10fa83790ecdce6ef83606195f43a14.png)  
    ![图 30](../../images/5b84a144b54a02835ec9e3e703329567415ce81f0193b5048819bb55a01fbe90.png) 
 -->


> [! cite]- 一位全加器的硬件逻辑实现
> ![图 28](../../images/04e484ab764132a4bf153feb9fc1e45e1e385b4a98cc8ad2d7485c47f80e1ca9.png)  
> #### 逻辑门
> ![图 29](../../images/fad53e0acd38225b0dfdd0275ac98ffaf10fa83790ecdce6ef83606195f43a14.png)  
> ![图 30](../../images/5b84a144b54a02835ec9e3e703329567415ce81f0193b5048819bb55a01fbe90.png)  
> #### 实现
> ![图 31](../../images/81656410b3824cdd7397d38af54fc2257fa463b50ee7ca0ca056b70ff6117498.png)  
> ![图 32](../../images/6c0e196b8ecad9f7babd58120793e674bcc24b5ecfd6deb8cb725059c8ca9ffc.png)  

![图 33](../../images/b759639e9ae3d757544dfedf879b6e39e20eae4179ef0409a7ab9a2ea4f1e557.png)  
### 串行进位加法器的硬件逻辑实现
![图 34](../../images/1fc8b90816801c2fbe2adae843d686427c9a3feacfdf43fe35927a5713b10e7b.png)  
##### 溢出检测
![图 35](../../images/8cb71c066e636dade2ba1f089d5d251ebe0389b83f4d801f04321d615623a2ad.png)  
![图 37](../../images/1d72a62295f754a6f49c8439f3b25b892b1b4e980f2092bb9f0ebb9acfc2d72e.png)  

### 减法
- Sub=1
![图 40](../../images/76acc65301ec7e662c42e7946ac2eac8ff406769ea1f5eacce2d7ee064c70834.png)  
 
- Sub=0 ， ==相当于低位进位$C_0$为0，不影响加法运算结果==
![图 41](../../images/0d920e721cce030db00f78eddd3ea02caeba0e38262699df5857ea38a6def099.png)  

> [! cite]- 性能
> ![图 42](../../images/f52fc95504dca4c1c3e18d6dbd614dfc060499a6fb81a5e836646099b1c46f45.png)  
> 在n位串行进位加法器中，每个高位的一位全加器FA的运算依赖于相邻低位的一位FA的进位$C_{i+1}$因此所有一位FA不能并行运行，其时间关键延迟为(2n+4)T，与串行进位加法器的位数n呈线性关系当n较大时性能较差。


## 先行进位加法器的硬件逻辑实现
### 可级联的4位先行进位电路
$C _ { i + 1 } = G _ { i } + P _ { i } C _ { i }$  
$G _ { i } = X _ { i } Y _ { i } \qquad P _ { i } = X _ { i } \bigoplus { + } Y _ { i }$
- 电路逻辑
![图 43](../../images/da86d20a9bcf7b8131178a4c19db1141022e9bd3cabfb62400b09f56be50ce92.png)  

#### 四位快速加法器
![图 44](../../images/fe9df6087e3ba9125dbc1bc511f8b4578ee1659f4a0f4a6478fe2d2d1023c7c8.png)  

#### 4位快速加法器与4位串行进位加法器性能比较
![图 45](../../images/4c9ed51b0677b5d65264319f05a1d9aba8bf973a7d2d6fae9e6dc0ef86bc295d.png)  

### 可级联的4位快速加法器
$C_{4}=G_{3}+P_{3}G_{2}+P_{3}P_{2}G_{1}+P_{3}P_{2}P_{1}G_{0}+P_{3}P_{2}P_{1}P_{0}C_{0}$  
$C_{4}=G^{*}+P^{*}C_{0}$  
$G^{*}=G_{3}+P_{3}G_{2}+P_{3}P_{2}G_{1}+P_{3}P_{2}P_{1}G_{0}$   
$P^*=P_3P_2P_1P_0$  



### 16位组内并行、组间并行加法器
![图 47](../../images/63844578070044b4fa028b2189087894f973074532b0a26e8c71c3cc470b1449.png)  

- 对比
![图 46](../../images/84b09c9b864053797a9cbe49405ad388aed4452062f09bdf90a1133cbd5664fe.png)  

--- 
# 无符号数乘法运算的硬件逻辑实现


![图 48](../../images/9af565c9f503914365cb2695c4068c28d67f3deff85045793777f9201ff5712e.png)  

### 机器实现过程
$\text{设 }x=0.1101,\:y=0.1011,\:\text{计算 }x\times y$  
$x\times y=2^{-1}(\:x\times1+2^{-1}(\:x\times1+2^{-1}(\:x\times1+0\:)))$

##### 初始状态
![图 50](../../images/177ffaaede5f1fdbcd70cb5cb239e5a4746c675ded4eeb485b838b4fe6f41035.png)  


##### $(X)+(ACC) \rightarrow ACC$
![图 51](../../images/0033ef22872b6afcf4bb438dcaaf9c62a38a715b3391e0aca6793b37fb57602c.png)  

##### $(C_{out})、(ACC)、(MQ)>>1$
![图 52](../../images/66b571e9e4c2a90f6d7daf4d0dc433f7c14f9f2c5c51b7fec2e7f9a670c6f4b8.png)  

<!-- ##### $(X)+(ACC) \rightarrow ACC$
![图 53](../../images/d57a2eab54fa841b0c7e0dddef180ca214332c03999b25f14466a63e53b943d1.png)   -->
##### 表格展示
![图 54](../../images/8f4478ef62698231ea0bfed9cc920da675b2474879bde97c7a4563c98d80e72f.png)  

> [! cite]  $\text{设 }x=0.1001,y=0.011\text{,计算 }x\times y$


--- 
# 定点数的乘法运算
### 原码乘法运算的硬件逻辑实现
- 由于原码表示与无符号数非常类似，仅比无符号数多一个符号，而乘积的符号可以通过参与运算的两个数各自符号的**逻辑异或**求得，因此，上述无符号数乘法运算的硬件逻辑实现，可用于原码一位乘法，仅需添加符号位处理即可。

##### 流程图

![图 55](../../images/b9c38051031cc7eecabe880177a0a2a0ad256ca304a96f27d87179901ca75195.png)  

##### 表格

![图 56](../../images/19af367b57c4fe326c49fd2cc9d8d47cdcb4162fd59b30fab844afeca963852e.png)  

- 对于定点整数原码乘法，其过程与定点小数原码乘法完全相同，仅将符号位与数值位之间的小数点改为逗号即可。
- 如果每次**根据乘数中的两位来计算位积**，则位积的数目会减少一半，因此循环累加次数将减少一半，可以大大提升乘法的运算速度，这种乘法称为**二位乘法**。

### 补码乘法运算的硬件逻辑实现
- 由于**计算机中采用补码表示数据**，如果用原码乘法计算两个数的乘积，则运算前需要将补码转换为原码、运算后还需要将原码再转换为补码，这样会增加许多操作步骤。为了减少处理环节，英国的布斯(Booth)夫妇于1950年提出了一种**补码乘法**，又称为**Booth算法**。

##### Booth算法
<!-- 好难，救命，别考 -->
![图 57](../../images/72c2d24da77720e850c8d171888d98f4e6d47e2805ba7d16896baf21b13e0928.png)  
![图 58](../../images/f6eba7f5f17b96c6823e15f900a0e61b4e74a569573deba6b1c5a88252233135.png)  
![图 59](../../images/fa139172677ba56d1add0199b895dabe92626f2e5ef497d58d11c6f6d4c2bc37.png)  
![图 60](../../images/fc6d866f85a4c4a173ca2161dcc2b3f11e99037e99f372acc405928abc9869d0.png)  
![图 61](../../images/2f23091ce05f0416024932986dd647a40541834a68c3393187228a887301a080.png)  
![图 62](../../images/6fc7fa50a24448702c75a7b8bc51c6de0a2939144a01830ff625e2e58365b8b8.png)  
$\begin{aligned}[x\times y\:]_{\text{补}}&=2^{-1}(2^{-1}(2^{-1}(2^{-1}(0+(0-1)\:[X]_{\text{补}})+(1-1)[X]_{\text{补}})+(1-0)[X]_{\text{补}})+(0-0)[X]_{\text{补}})+(0-1)[X]_{\text{补}}\\&=2^{-1}(2^{-1}(2^{-1}(2^{-1}(0+[-X]_{\text{补}})+0)+[X]_{\text{补}}\end{aligned}$
- 每轮次中的右移一位，全部是**补码的算术右移**，即移位后，空出的高位用符号位的值添补。
![图 63](../../images/9d62e481a8e5b2920bd82fcd4daa29779084d332d2e9ff322e0fe664ae0837d9.png)  

##### 初始化
![图 64](../../images/819624fd78a40c8503b70d5ed3407e45d3ed6cfe4c741552475179b528314244.png)  

##### $((\overline{\mathrm{X}})+1)+(\mathrm{ACC})\to\mathrm{ACC}$
![图 65](../../images/60f465e95c05436e821fdebd681e864096a4b23e847ca9dde04313ea7ee8fc57.png)  


##### $(ACC)、(MQ)>>1$
![图 67](../../images/57060a715ac3c27c4bcc8ea208436274ef40bee26833786c28b0c9e059d064ff.png)  

##### 表格
![图 68](../../images/a523d7114f7f04e8aba7de32ae95eb0dc4510e1c5081510cd0adff7912e3e033.png)  

> [! cite]  $\text{设 }x=0.1101,\:y=-0.1001,\:\text{计算}[\:x\times y\:]_\text{补}$

##### 流程图
![图 69](../../images/215b6be8496d8b37ff0bff1322addfd1fede54edc41f7d9c2c1b7e096fdbe05b.png)  

### 无符号阵列乘法器
- 原码、补码一位乘法的硬件逻辑实现，需要在时钟节拍下、通过控制逻辑的控制，执行相应轮次的“加法、右移”操作来实现，速度较慢  
- 为了提高运算速度，可以仅采用组合逻辑电路以专用硬件方式构建阵列乘法器  
- 构建阵列乘法器的基本思想是模仿二进制乘法的笔算方法  

#####  二进制乘法的笔算方法

![图 70](../../images/8d89419c9ebfb375d43110f075e581557dd47aec8a907ed028a00348ff7a2cda.png) 

##### 无符号阵列乘法器

<!-- ![图 71](../../images/3deda2f795f27297baabdba81073e1aa5e3603d049732bc06e3527db20dc0ff1.png)   -->
![图 72](../../images/6867e28e33db4e30a18b822ddf1b28c8bf4eb82a627ee27ff5ff8ad6d3d07185.png)  
![图 73](../../images/440c842d37a62f136200ddcaac40bc17b71cb3bda0732c8571fccd6f233e4669.png)  

- 阵列乘法器结构规范标准化程度高，有利于布局布线，适合用超大规模集成电路实现，且可以获得较高的运算速度，其运算速度仅取决于逻辑门和加法器的传输延迟

### 补码阵列乘法器
[待补充……](https://www.bilibili.com/video/BV1Mw4m1U7NQ?t=3.6&p=35)

### 原码除法运算（恢复余数法）
- 由于原码表示与无符号数非常类似，仅比无符号数多一个符号，因此，进行原码除法运算时，**可将符号位与数值部分分开处理**。
  - 商的符号：由被除数和除数各自的**符号**进行**异或**运算求得
  - 商的数值部分：由被除数和除数各自的**数值部分**（即==真值的绝对值==）**相除**求得

![图 74](../../images/841f2d323e124efc03d9ba18ca811a12f7d1e423e13206d79b1399851aa70534.png)  

- 以上是定点小数（纯小数）原码除法运算的处理方法，为了确保商和余数也为定点小数（即不发生溢出）上述除法的条件为$|X|<|Y|$
- 同理，定点整数原码除法运算的条件为$|X|\geq|Y|$

##### 原码除法的法则
1. 前提条件
   - 除数≠0
   - 定点小数：| 被除数 | $<$ | 除数 |
   - 定点整数：| 被除数 | $\geq$ | 除数 |
2. **商的符号**=被除数的符号⊕除数的符号
3. ==| 商 |== = | 被除数 | ÷ | 除数 |
4. 将**商的符号**与 ==| 商 |== 拼接在一起

##### 二进制除法笔算过程
![图 75](../../images/dbfa6036c654378898021ce4c43a61f476e20aa19e29d74b39c3d515ff292006.png)  

##### 模拟二进制除法笔算过程
- 计算机无法直接判断大小，只能首先默认"够减"
![图 76](../../images/cb127c7c10f26c54eb519d3ff7327fc427d13afc7788ebb49565c1916c83c30e.png)  


![图 77](../../images/5ff1677d88eaba18bc7b755ec09ea6fdda6b6f491eba6d2a1d6e28ab6f46a0cb.png)  

- 从本例可以看出，由于运算过程中可能需要恢复余数，并且恢复余数的次数和具体的操作数相关，极端情况下每一步运算都需要恢复余数，因 此，该方法的最大**缺点**是运算**时间不确定**，另外，其**控制电路也比较复杂**  


> [!cite] $\text{设}[x]_{\text{原}}=0.1011,[y]_{\text{原}}=1.1101\text{,用恢复余数法,求}[x]_{\text{原}}\div[y]_{\text{原}}$

### 原码除法运算（不恢复余数法）
![图 78](../../images/d453c0a82080c089b3d96de58d41596c19466a32403efbc4fa782a9cbd15ea99.png)  

- 当第$i$次中间余数$R_i$为负时，可以**跳过恢复余数**这一步，直接求第$i+1$次中间余数$R_{i+1}$。这种算法称为**不恢复余数法**

##### 举例
![图 80](../../images/bb3d79c03eefa1609d405774ad5a15ceffba00d49405fc6cafe36c4364e711d1.png)  

> [!cite] $\text{设}[x]_\text{原}=0.1011,[y]_\text{原}=1.1101,\text{用不恢复余数法,求}[x]_\text{原}\div[y]_\text{原}$

### 补码除法运算（不恢复余数法）
[待补充……](https://www.bilibili.com/video/BV14w4m197Ub?t=13.2&p=38)

--- 
# 浮点运算
### 浮点加减法运算

1. 对阶
2. 尾数运算
3. 结果规格化
4. 舍入处理
   
![图 81](../../images/609fdfe50eaf0af6596f4735fd9ab830e0cff9276ad74b522d6ef715503b818d.png)  

- 在尾数右规时，尾数末位的几位会因超出计算机字长而被丢弃，从而产生误差。此时，计算机可以按选定的方式进行**舍入**操作  
- 在尾数规格化和尾数舍入时，可能会对结果的阶码执行加、减运算。因此，必须考虑结果的阶码出现**溢出**的问题  
	- 由于浮点数中阶码的位数决定了浮点数的表示范围，因此，对于浮点运算，当**阶码出现溢出时**，表示运算**结果出现溢出**

[待补充……](https://www.bilibili.com/video/BV1Lm421g7dG?t=152.1&p=39)

### IEEE 754浮点数加减法运算
同上


### 浮点数乘法
同上


### 浮点数除法
同上


--- 
# 运算器

- 计算机中的**各类算术运算**都可以**利用基本的定点加法运算和移位运算来实现**  
- 将实现加法运算、移位运算、逻辑运算以及各种算术运算所需的数字逻辑电路集成在一起，就可以构成**CPU中的运算器**
- 运算器一般分为以下两种
  - `定点运算器`：以**算术逻辑单元ALU**为核心，可以进行定点数的移位、算术、逻辑运算  
	- `浮点运算器`：以**浮点运算单元FPU**为核心，负责进行浮点数的算术运算  

> [! info] 浮点运算比定点运算复杂得多，因此，实现浮点运算的逻辑电路也比较复杂，早期将其实现电路集成在一个单独的芯片中，目前大多集成在CPU内部

![图 82](../../images/25f4148749a85aa24b2439eb534bb11687ab3d5ca777097c428cfd149bdc9808.png)  

- 不同计算机利用这些标志的方法和时机可能不同












