# 汇编语言基础知识


## 汇编语言的基本组成部分
- **指令 (Instruction)**: 汇编语言的基本单元，每条指令指示CPU执行一个操作。
- **操作数 (Operands)**: 指令操作的对象，可以是寄存器、内存地址或立即数。
- **寄存器 (Register)**: CPU中的小型存储单元，用于存储数据和执行操作。
- **内存地址 (Memory Address)**: 内存中的位置，用于存储和访问数据。
- **汇编器 (Assembler)**: 将汇编代码转换为机器代码的工具。

## 汇编代码的结构
- **标签 (Label)**: 可选，表示代码中的某个位置，通常用于跳转指令的目标。
- **操作码 (Opcode)**: 表示要执行的操作，例如 `MOV`、`ADD` 等。
- **操作数 (Operands)**: 指定指令作用的对象，可以是寄存器、内存地址或立即数。
- **注释 (Comment)**: 以 `;` 开头的文本，用于解释代码，不会被汇编器翻译。

## 汇编语言常用命令

| **命令** |             **解析**              |                           **示例**                           |
| :----: | :-----------------------------: | :--------------------------------------------------------: |
| `MOV`  |        将数据从一个位置移动到另一个位置。        |           `MOV AX, BX` 将 `BX` 寄存器的值移动到 `AX` 寄存器。           |
| `ADD`  |     将两个操作数相加，并将结果存储在目标操作数中。     |      `ADD AX, BX` 将 `AX` 和 `BX` 的值相加，并将结果存储在 `AX` 中。       |
| `SUB`  | 从第一个操作数中减去第二个操作数，并将结果存储在目标操作数中。 |      `SUB AX, BX` 从 `AX` 中减去 `BX` 的值，并将结果存储在 `AX` 中。       |
| `INC`  |        将指定寄存器或内存地址的值加一。         |                  `INC AX` 将 `AX` 寄存器的值加一。                  |
| `DEC`  |        将指定寄存器或内存地址的值减一。         |                  `DEC AX` 将 `AX` 寄存器的值减一。                  |
| `MUL`  |            无符号乘法运算。             |    `MUL BX` 将 `AX` 寄存器的值与 `BX` 寄存器的值相乘，结果存储在 `DX:AX` 中。    |
| `DIV`  |            无符号除法运算。             | `DIV BX` 将 `DX:AX` 中的值除以 `BX` 的值，商存储在 `AX` 中，余数存储在 `DX` 中。 |
| `JMP`  |           无条件跳转到指定标签。           |                `JMP LABEL` 跳转到 `LABEL` 标签。                 |
| `CMP`  |        比较两个操作数，并设置状态标志。         |              `CMP AX, BX` 比较 `AX` 和 `BX` 的值。               |
|  `JE`  |    如果相等标志 (ZF) 被设置，则跳转到指定标签。    |         `JE LABEL` 如果前一条指令比较结果相等，则跳转到 `LABEL` 标签。          |
| `JNE`  |   如果相等标志 (ZF) 未被设置，则跳转到指定标签。    |        `JNE LABEL` 如果前一条指令比较结果不相等，则跳转到 `LABEL` 标签。         |
| `PUSH` |            将数据压入栈中。             |                 `PUSH AX` 将 `AX` 寄存器的值压入栈。                 |
| `POP`  |            从栈中弹出数据。             |                `POP AX` 将栈顶的值弹出到 `AX` 寄存器中。                |
| `CALL` |             调用子程序。              |                 `CALL FUNC` 调用 `FUNC` 子程序。                 |
| `RET`  |             从子程序返回。             |                      `RET` 从当前子程序返回。                       |
| `NOP`  |          无操作指令，通常用于占位。          |                        `NOP` 执行无操作。                        |
| `AND`  |             按位与操作。              |           `AND AX, BX` 对 `AX` 和 `BX` 的值进行按位与操作。            |
|  `OR`  |             按位或操作。              |            `OR AX, BX` 对 `AX` 和 `BX` 的值进行按位或操作。            |
| `XOR`  |             按位异或操作。             |           `XOR AX, BX` 对 `AX` 和 `BX` 的值进行按位异或操作。           |
| `NOT`  |             按位取反操作。             |                 `NOT AX` 将 `AX` 寄存器的值按位取反。                 |
| `SHL`  |             逻辑左移操作。             |               `SHL AX, 1` 将 `AX` 寄存器的值左移一位。                |
| `SHR`  |             逻辑右移操作。             |               `SHR AX, 1` 将 `AX` 寄存器的值右移一位。                |
| `INT`  |              触发中断。              |                  `INT 21H` 调用DOS中断21H服务。                   |
| `CLC`  |          清除进位标志 (CF)。           |                       `CLC` 清除进位标志。                        |
| `STC`  |          设置进位标志 (CF)。           |                       `STC` 设置进位标志。                        |
| `HLT`  |            停止处理器执行。             |                   `HLT` 停止处理器执行，直到下一次中断。                   |


